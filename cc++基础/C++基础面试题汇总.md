# C++面试题汇总

## 1：基础篇

### 1.1**哪些函数无法设置成虚函数**：

1. **静态成员函数**：静态成员函数不依赖于类的任何特定实例，而虚函数的调用需要通过对象的指针或引用来动态绑定，因此静态成员函数不能是虚函数。
2. **构造函数**：构造函数用于初始化对象的状态，而虚函数的机制是在对象完全构造后才能使用。因此，构造函数不能被声明为虚函数。然而，虚析构函数是一个例外，它确保当通过基类指针删除派生类对象时，可以正确地调用派生类的析构函数。
3. **友元函数**：友元函数不是类的成员函数，而是定义为在类外部可以访问类的私有成员的函数。因为友元函数不属于类的成员，所以不能被声明为虚函数。
4. **内联函数**：虽然内联函数可以是虚函数，但是当虚函数在类内部被定义为内联时，只有在它被编译器内联展开的情况下才真正发挥内联的效果。如果通过基类或派生类的指针或引用调用虚函数，通常无法在编译时确定要调用的确切函数体，这时内联展开就不会发生。因此，将虚函数定义为内联函数可能不会按预期工作，特别是在多态调用中。
5. **析构函数**：虽然析构函数可以是虚函数，且通常推荐将基类的析构函数声明为虚析构函数以保证正确的资源回收，但是全局函数、静态函数等不属于类成员的函数自然不能声明为虚函数。

**重点说明第二点**：

主要是对象实例化的本质：**在C++中，虚函数机制依赖于对象中的虚函数表（vtable**），而这个**虚函数表只有在对象的构造函数执行后才会被设置**。如果构造函数是虚的，当尝试创建一个对象时，就需要访问这个还未设置的虚函数表来调用正确的构造函数，这显然是不可能的。因此，构造函数必须是非虚的，以确保对象可以正确地构造。

### **1.2 c++从代码到二进制可执行文件的过程**：

C++代码到二进制可执行文件的过程涵盖了代码的**预处理、编译、汇编和链接**。这个过程由多个工具协作完成，包括预处理器、编译器、汇编器和链接器，

### **1.3动态库与静态库**

静态库

- **载入时机**：静态库在程序的链接阶段（即上述过程的第四步：链接）被载入。链接器将静态库中被应用程序引用到的代码和数据直接合并到最终的可执行文件中。
- **特点**：因为静态库的内容被直接包含在最终的可执行文件中，所以程序运行时不需要静态库文件。这种方式简化了程序的部署，因为不需要确保运行环境中存在特定的库文件。但缺点是，如果多个程序都使用同一个静态库，那么每个程序的可执行文件中都会包含一份库的拷贝，导致资源浪费。

动态库

- **载入时机**：动态库（在Windows上称为DLL，在UNIX和Linux系统上通常称为共享对象或SO文件）是在程序运行时被动态载入的。当可执行文件被操作系统加载到内存时，动态链接器（运行时链接器）负责载入那些程序依赖的动态库，并解析出程序中对库函数和数据的引用。
- **特点**：动态库的一个主要优点是代码重用和节省空间。多个运行中的程序可以共享同一份物理内存中的库代码，减少了冗余。此外，更新动态库不需要重新编译依赖它的程序，只需替换库文件即可。但是，这也带来了复杂的版本依赖和兼容性问题，以及潜在的运行时加载错误。

对比：

- 两者的载入事件不同，静态库一边是在编译成可执行文件图中装入的，每个引用静态库的可执行文件都得从中拷贝一份，而且一旦修改静态库，则要重新编译可执行文件

总结

- 静态库在程序的链接阶段被包含进最终的二进制可执行文件中，与可执行文件一同分发。
- 动态库在程序运行时被载入，可以由多个程序共享，但需要管理库的版本和兼容性。

### 1.4多态：

**主要分为静态多态和动态多态**：

**静态多态**

- **实现方式**：静态多态主要通过函数重载（Overloading）和模板（Templates）来实现。在编译时，编译器根据参数的类型、数量以及模板参数来决定调用哪个具体的函数或实例化哪个模板。这种在编译期间进行的绑定也称为早绑定（Early Binding）。
- **特点**：因为静态多态的解析发生在编译时，所以它不会带来运行时的性能开销。但它也不具备运行时改变行为的灵活性。

动态多态

- **实现方式**：动态多态主要是通过虚函数（Virtual Functions）来实现的。当一个类中声明了虚函数时，派生类可以覆盖（Override）这个函数以提供特定的实现。C++11引入了`override`关键字，可以（并且建议）在派生类中用来明确表示函数覆盖了基类的虚函数，但这并不是实现动态多态所必需的。
- **特点**：动态多态的解析发生在运行时，通过虚函数表（VTable）来实现。当通过基类的指针或引用调用虚函数时，会根据对象的实际类型来动态决定调用哪个函数。这种在运行时进行的绑定也称为晚绑定（Late Binding）。

### 1.5 const 和 define的区别 

该回答可以引出C++11后constexpr

define：define用来定义宏，它只是简单的展开，没有类型检测，不受命名空间的限制，用的不好会造成宏泛滥问题，宏的处理一般时在预处理阶段

const：一般用来限定变量使得变量的值无法被改变，const作用与类型，所以会类型检测，const修饰的变量受命名空间的限定，const修饰都是在编译阶段

c++11之后，引进了constexpr，它拥有const的所有功能，`constexpr`确保表达式在编译时可求值，从而允许和要求编译器在编译期计算表达式的值，而非运行时

### 1.6 malloc，new的区别

**malloc**

malloc是C语言库中函数，用于分配内存到堆区，要显示的指出分配内存的大小主要基于底层的brk和mmap函数，在申请内存小于等于128kb时使用brk，大于时使用mmap，malloc在分配内存时除了分配变量要的内存还会在这段地址前后加上cookie，上下共8字节，对于内存小的而言，内存使用率很低

**new**

new是c++在堆区分配内存的关键词，new底层还是基于全局的::operator new,底层实际上也是基于malloc，也可以重载局部的operator new

**总结**

`malloc`是C语言中用于分配内存的函数，不会初始化内存，返回`void*`需要类型转换，分配失败返回`NULL`。`new`是C++的操作符，分配内存的同时调用构造函数初始化对象，类型安全不需转换，分配失败抛出异常。`malloc`与`free`配对，`new`与`delete`配对，`new`更适合C++的对象模型和异常机制。

#### 1.6.1 补充 malloc底层实现原理

**小块内存分配**：对于小于某个阈值（例如128KB）的内存分配请求，`malloc`使用`brk`或`sbrk`系统调用来调整程序数据段的大小

**大块内存分配**：对于大于阈值的内存请求，`malloc`通过`mmap`系统调用直接向操作系统请求内存。这些内存区域通常被称为匿名映射（anonymous mappings），因为它们不与任何文件关联。使用`mmap`分配的内存可以在释放时直接返回给操作系统，从而减少了内存碎片。

### 1.7 智能指针系列

#### 1.7.1 什么是智能指针，与裸指针相比，它的主要优势是什么

智能指针借鉴RAII思想可以自动管理变量的生命周期，相比于裸指针，更加内存安全

c++标准库中提供了unique_ptr,shared_ptr,weak_ptr

#### 1.7.2 **使用场景和原理**

- unqiue_ptr,它是对某个变量的独占，其他指针无法指向这个变量，它的内部禁止拷贝构造和等号重载，支持移动拷贝构造，当其作为函数的参数时，只支持右值传入就是借助std::move
- shared_ptr,共享指针，对于我个人而言一般使用在对象跨线程，因为对象跨线程下，析构函数不安全，会导致程序在运行时出现未定义行为，它内部支持拷贝构造和等号重载，这些都会导致计数的增加，当其作为参数时，引用传参,std::move,指针都不会引起它计数的增加，值传递会引发计数的增加
- weak_ptr,它不会引起计数增加，一般解决shared_ptr循环引用问题，weak_ptr也能晋升成shared_ptr

#### 1.7.3 手动实现智能指针

```c++
template <class T>
class unique_ptr {
public:
    explicit unique_ptr(T* ptr = nullptr) : p(ptr) {}
    
    ~unique_ptr() {
        delete p;
    }
    
    // 禁止拷贝构造和拷贝赋值
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
    
    // 支持移动构造
    unique_ptr(unique_ptr&& other) noexcept : p(other.p) {
        other.p = nullptr;
    }
    
    // 支持移动赋值
    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            delete p;
            p = other.p;
            other.p = nullptr;
        }
        return *this;
    }
    
    T* get() const {
        return p;
    }
    
private:
    T* p;
};

```

```c++
//*shared_ptr
template <class T>
class shared_ptr {
public:
    explicit shared_ptr(T* ptr = nullptr) : p(ptr), count(new std::atomic<int>(1)) {}
    
    ~shared_ptr() {
        if (p && --(*count) == 0) {
            delete p;
            delete count;
        }
    }
    
    shared_ptr(const shared_ptr& other) : p(other.p), count(other.count) {
        ++(*count);
    }
    
    shared_ptr& operator=(const shared_ptr& other) {
        if (this != &other) {
            // 减少原有对象的引用计数，并可能删除
            if (--(*count) == 0) {
                delete p;
                delete count;
            }
            // 复制新对象的数据
            p = other.p;
            count = other.count;
            ++(*count);
        }
        return *this;
    }
    
    shared_ptr(shared_ptr&& other) noexcept : p(other.p), count(other.count) {
        other.p = nullptr;
        other.count = nullptr;
    }
    
    shared_ptr& operator=(shared_ptr&& other) noexcept {
        if (this != &other) {
            p = other.p;
            count = other.count;
            other.p = nullptr;
            other.count = nullptr;
        }
        return *this;
    }
    
private:
    T* p;
    std::atomic<int>* count;
};
```

#### 1.7.4 weak_ptr指针是如何避免指针悬空

`std::weak_ptr`通过其`lock`方法提供了一种安全访问机制，能够防止悬挂指针问题，允许安全地检查并访问由`std::shared_ptr`管理的对象，而不增加对象的引用计数。

#### 1.7.4 高级应用

**在什么情况下会选择手动管理内存而不使用智能指针？**

- **性能敏感区域**：智能指针的额外层次可能引入轻微的性能开销，如引用计数的增减。
- **高级内存管理策略**：在实现特定的内存管理策略，如内存池、垃圾收集机制或特殊的对象缓存时，可能需要细粒度地控制内存分配和释放过程。

**如何在类成员中正确使用智能指针来避免资源泄漏？**

- **成员资源所有权**：如果类独占某资源，应使用`std::unique_ptr`作为成员变量。这样，当类实例被销毁时，`unique_ptr`也会自动释放其管理的资源。
- **共享资源**：如果类与其他对象共享资源，可以使用`std::shared_ptr`。这确保了只要还有`shared_ptr`指向资源，资源就不会被销毁。
- **避免循环引用**：如果使用`std::shared_ptr`可能导致循环引用，导致资源无法释放，可以将部分成员改为`std::weak_ptr`来打破循环。

**你能解释智能指针的自定义删除器是什么吗，以及如何使用它？**

- 智能指针的自定义删除器允许你指定一个函数或函数对象，当智能指针需要释放其所管理的资源时调用，这对于非默认释放资源的情况特别有用。

exmaple：

```c++
#include <memory>
#include <iostream>
#include <fstream>

void customDeleter(FILE* ptr) {
    fclose(ptr);
    std::cout << "File closed.\n";
}

int main() {
    std::unique_ptr<FILE, decltype(&customDeleter)> filePtr(fopen("example.txt", "r"), &customDeleter);
    // 使用filePtr...
}

```

#### 1.7.5 智能指针性能问题与陷阱

**性能考虑****与陷阱**：

- **引用计数的开销**，比如shared_ptr中的计数，它要保证线程安全，借助线程同步原语会造成性能的开销
- **动态分配内存**：虽然`std::shared_ptr`自身通常很小，但它需要在堆上分配一个控制块（用于存储引用计数和可能的自定义删除器等信息）虽然`std::shared_ptr`自身通常很小，但它需要在堆上分配一个控制块（用于存储引用计数和可能的自定义删除器等信息），**使得小对象或原始类型也会涉及动态内存分配，可能会影响性能。**
- **间接访问问题**，在利用指针频繁访问，会导致命中不了
- 共享指针的循环引用问题
- **自定义删除器的复杂性**

#### 1.7.6 智能指针与STL容器的问题

鼓励使用容器加智能指针

## 2：面向对象篇

### 2.1 基本概念和原则

四大基本原则：（封装、抽象、继承、多态）

#### **封装**：

封装是面向对象编程的核心原则之一，它涉及将数据（属性）和操作这些数据的方法（行为）捆绑在一起形成类。封装的目的在于：

- **隐藏实现细节**：用户只能看到对象的公共接口，而不需要关心内部实现细节，这有助于降低系统的复杂性。
- **数据安全**：通过限制对类成员的直接访问（例如，使用`private`或`protected`访问修饰符），可以防止外部代码随意修改对象的内部状态，从而保证数据的完整性和安全性。
- **易于修改和扩展**：封装使得对象的实现可以独立于接口，这意味着在不影响外部代码的情况下，开发者可以自由地改进和扩展对象的内部实现。

#### 抽象：

抽象是通过隐藏具体实现细节，仅展示对象的关键信息和行为的过程。在面向对象编程中，抽象通常是通过定义接口或抽象基类来实现的：

- **纯虚函数和抽象类**：抽象类通过包含至少一个纯虚函数（`virtual function = 0`）来提供一个或多个未实现的接口。派生类必须实现这些纯虚函数，提供具体的功能实现。
- **多态**：抽象的强大之处在于支持多态，允许通过基类的引用或指针，调用派生类中重写的方法。这使得程序在运行时可以根据对象的实际类型调用相应的方法，而不是在编译时。

### 2.2 设计模式

#### 2.2.1 单列模式

面试时手写两种单列模式和如何延伸：

单列模式的实现，提供两种（饿汉和c++11后的实现）-引出懒汉的问题并且提出原子量

**饿汉与懒汉的对比：**

- eager initialization （饿汉）
  - 定义：
    - eager initialization 顾名思义就是在进入程序时直接实例化（类的静态成员，被所有类对象共享）。
  - 优点：
    - 不用考虑多线程安全，因为即使是多线程程序，在进入的时候一般都是单线程。
    - 因为预先创建好了，所以调用时反应速度快。
  - 缺点：
    - 资源效率，所有实例在程序开始时创建，可能会造成卡顿。
- lazy initialization （懒汉）
  - 定义：
    - lazy initialization 顾名思义，等到要用的时候再实例化。
  - 优点：
    - 资源利用率高，要用的时候再实例化，很好的节省了资源。
  - 缺点：
    - 在多线程的情况下容易产生线程安全问题。
    - 第一次加载时不够快。

首先说明一下，一般单列模式都是定义成模板类或者模板函数，要把要单列化的对象封装进去

1：饿汉模式

```
class singleton {
private:
    singleton() {}
    static singleton *p;
public:
    static singleton *instance();
};

singleton *singleton::p = new singleton();
singleton* singleton::instance() {
    return p;
}
```

2:c++11只后的实现：

```c++
template <class T>
class Sigleton{
public:
	static T & instance{
		static T* p ;
		return *p;
}
	
};
```

这时候有可能会问怎么使得懒汉模式在多线程环境下的安全，一开始是双重加锁，但是c++11之前还是不安全因为表达式如（p = new T（）的顺序是不知道的，会引发很多问题，c++11之后是安全的），引出原子变量，atomic

#### 2.2.2 生产者与消费者模型

**线程池的实现：**

基于生产者与消费者

```c++

```

### **2.3 高级特性**

解释虚函数、纯虚函数和抽象类的区别和联系

#### 虚函数（Virtual Function）

- **定义**：在基类中声明为`virtual`的成员函数。当通过基类指针或引用调用虚函数时，会根据对象的实际类型来决定调用哪个版本的函数，这个过程在运行时进行，称为动态绑定或晚绑定。
- **用途**：允许派生类重写基类中的虚函数，提供自己的实现。这是实现多态的基础。
- **特点**：虚函数可以有自己的实现，也可以不做任何实现（即留空）。

#### 纯虚函数（Pure Virtual Function）

- **定义**：在基类中声明为`= 0`的虚函数，例如`virtual void foo() = 0;`。
- **用途**：纯虚函数使得基类不能直接实例化，只能通过其派生类来实例化。派生类必须提供纯虚函数的具体实现，除非该派生类也是抽象类。
- **特点**：纯虚函数声明了一个接口，没有提供默认的实现。它强制派生类遵循特定的接口。

#### 抽象类（Abstract Class）

- **定义**：包含至少一个纯虚函数的类。
- **用途**：抽象类作为基类，定义了一个接口和/或部分实现，供派生类继承和实现。抽象类不能被实例化。
- **特点**：抽象类通常用于定义基础的、通用的框架或协议，让派生类填充具体的功能。

#### 区别和联系

- **区别**：虚函数是允许派生类重写的函数，它可以有默认实现；纯虚函数是必须由派生类实现的接口，没有默认实现；抽象类是包含纯虚函数的类，用于定义接口。
- **联系**：它们共同实现了C++中的多态性。通过虚函数和纯虚函数的声明，抽象类提供了一种机制，允许对象表现出多种形式（多态）。派生类通过重写这些函数来提供具体的实现。

### 2.4 虚函数表与虚函数指针的问题

#### **虚函数表（vtable）是什么？它在C++对象模型中是如何工作的？**

C++中，虚函数表（vtable）是实现动态多态的一种机制，存在于程序的只读端。每一个含有虚函数的类都会有一个对应的虚函数表，这个表是一个编译时生成的数组，其中存储了指向类虚函数的指针

**工作流程**：

1. **对象实例化时**：当一个类的对象被创建时，对象内部的虚指针（vptr）会被自动初始化为指向该类的虚函数表（vtable）。
2. **调用虚函数时**：通过对象调用虚函数时，程序会先通过对象内部的vptr找到对应的虚函数表，然后根据虚函数在虚函数表中的偏移量找到正确的函数地址，并跳转到该地址执行函数。
3. **派生类对象时**：如果通过基类指针或引用调用虚函数，程序同样会通过vptr访问虚函数表，但由于派生类对象的vptr指向的是派生类的虚函数表，即使使用基类的指针或引用，也能正确调用到派生类中重写的虚函数。

#### **虚函数指针（vptr）是如何在类的继承体系中工作的？**

在C++类继承体系中，每个对象内部都有一个虚函数指针（vptr），它指向类的虚函数表（vtable）。vtable包含了类中所有虚函数的地址。

- 在**构造对象**时，vptr会被初始化为指向该对象实际类型的vtable。
- 如果是**派生类对象**，其构造过程中vptr首先指向基类的vtable，随着构造函数的逐层调用，最终指向派生类的vtable。这确保了即使通过基类指针访问时，也能调用到派生类中重写的虚函数，实现多态性。
- 在**多重继承**中，一个派生类对象可能有多个vptr，分别指向各个基类的vtable，以支持对每个基类虚函数的正确调用。

简而言之，vptr和vtable一起工作，保证了在类的继承体系中，虚函数调用总是解析到对象实际类型的函数实现，支持C++的动态多态特性。

#### 多重继承下的虚函数表是如何组织的？

在C++的多重继承中，虚函数表（vtable）的组织方式较为复杂，以确保可以正确处理来自多个基类的虚函数。具体的组织方式依赖于编译器的实现，但通常遵循以下原则：

1. **每个基类有自己的vtable**：在多重继承中，每个基类都会有自己的一套虚函数，因此也就有自己的虚函数表（vtable）。当一个派生类继承自多个基类时，它将继承这些基类的vtable。
2. **派生类的vtable**：派生类会为每个基类维护一个vtable的拷贝或部分拷贝，如果派生类重写了来自某个基类的虚函数，那么对应基类的vtable拷贝中的那个函数指针将被更新为指向派生类中的新实现。
3. **虚指针（vptr）**：在多重继承的情况下，派生类对象可能会包含多个虚指针（vptr），每个vptr对应一个基类的vtable。这意味着对象的内存布局中会包含多个vptr，每个vptr指向对应基类函数的虚函数表。
4. **内存布局**：派生类对象的内存布局中，会首先包含第一个基类的数据成员和vptr，接着是第二个基类的数据成员和vptr，依此类推。这样，当通过某个基类的指针访问派生类对象时，相应的vptr能确保调用到正确的虚函数实现。